# -*- coding: utf-8 -*-
"""ТЭР.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1bEB4DwTQyEdos3LB9lRjo0qot1eHZh_c
"""

path_not_proc = 'app/data/energy_data.csv'
path_proc = 'app/data/data.csv'

import matplotlib.pyplot as plt
import numpy as np
import pandas as pd
import seaborn as sns
import torch
import torch.nn as nn
import torch.optim as optim
from sklearn.ensemble import RandomForestRegressor
from sklearn.linear_model import LinearRegression
from sklearn.preprocessing import MinMaxScaler
from statsmodels.tsa.arima.model import ARIMA
from tensorflow.keras.layers import LSTM
from tensorflow.keras.models import Sequential
from tensorflow.keras.layers import Dense
from utils.metrics import calculate_metrics, save_metrics_to_db, print_all_metrics

# Загрузка данных
file_path = path_not_proc  # Укажите правильный путь к файлу
df = pd.read_csv(file_path)
df.head()

# Загрузка данных
file_path = path_not_proc  # Укажите правильный путь к файлу
df = pd.read_csv(file_path)

# Удаление неназванных столбцов
df = df.loc[:, ~df.columns.str.contains('Unnamed')]

# Обнаружение категориальных столбцов
non_numeric_columns = df.select_dtypes(include=['object']).columns

# Кодирование категориальных данных (One-Hot Encoding)
df = pd.get_dummies(df, columns=non_numeric_columns)

# Заполнение пропущенных значений (линейная интерполяция)
df.interpolate(method='linear', inplace=True)

# Нормализация данных (Min-Max Scaling)
scaler = MinMaxScaler()
df_scaled = pd.DataFrame(scaler.fit_transform(df), columns=df.columns)

# Сохранение обработанного датасета
df_scaled.to_csv("processed_energy_data.csv", index=False)

print("Предобработка данных завершена. Файл сохранён как processed_energy_data.csv")

# Загрузка обработанных данных
file_path = path_proc  # Укажите правильный путь к файлу
df = pd.read_csv(file_path)

# Первичный анализ данных
print("Основные статистики:\n", df.describe())
print("Корреляции между признаками:\n", df.corr())

# Визуализация корреляционной матрицы
# plt.figure(figsize=(12, 6))
# sns.heatmap(df.corr(), annot=True, cmap="coolwarm", fmt=".2f")
# plt.title("Корреляционная матрица")
# plt.show()

# Визуализация временных рядов
# plt.figure(figsize=(14, 6))
# for column in df.columns[:5]:  # Ограничимся первыми 5 столбцами для наглядности
#     plt.plot(df.index, df[column], label=column)
# plt.legend()
# plt.title("Графики временных рядов первых 5 признаков")
# plt.xlabel("Время")
# plt.ylabel("Значения")
# plt.show()

print("Первичный анализ завершён.")

import matplotlib.pyplot as plt
import numpy as np
import pandas as pd
from statsmodels.tsa.arima.model import ARIMA
from sklearn.linear_model import LinearRegression
from sklearn.ensemble import RandomForestRegressor
from tensorflow.keras.models import Sequential
from tensorflow.keras.layers import Dense, LSTM
from sklearn.preprocessing import MinMaxScaler

# Загрузка данных (предположим, что данные уже загружены в переменную df)
df = pd.read_csv(path_not_proc)

# Группировка данных
df_grouped = df.groupby([df.columns[0], df.columns[1]])[df.columns[5]].sum().reset_index()
df_grouped = df_grouped.rename(columns={df.columns[0]: 'Год', df.columns[1]: 'Топливо', df.columns[5]: 'Валовое потребление ТЭР'})

# Заполнение пропущенных значений средним по каждому виду топлива
df_grouped['Валовое потребление ТЭР'] = df_grouped.groupby('Топливо')['Валовое потребление ТЭР'].transform(lambda x: x.fillna(x.mean()))

# Разделение данных на фактические (2005-2020) и прогнозные (2021-2030)
df_actual = df_grouped[df_grouped['Год'] <= 2020]

# Функция для предсказания с помощью ARIMA
def arima_forecast(data, steps=10):
    model = ARIMA(data, order=(5, 1, 0))  # (p,d,q) гиперпараметры ARIMA
    model_fit = model.fit()
    forecast = model_fit.forecast(steps=steps)
    return forecast

# Функция для предсказания с помощью линейной регрессии
def linear_regression_forecast(data, steps=10):
    model = LinearRegression()
    years = np.array(range(len(data))).reshape(-1, 1)
    model.fit(years, data)
    forecast = model.predict(np.array(range(len(data), len(data) + steps)).reshape(-1, 1))
    return forecast

# Функция для предсказания с помощью Random Forest
def rf_forecast(data, steps=10):
    model = RandomForestRegressor(n_estimators=100, random_state=42)
    years = np.array(range(len(data))).reshape(-1, 1)
    model.fit(years, data)
    forecast = model.predict(np.array(range(len(data), len(data) + steps)).reshape(-1, 1))
    return forecast

# Функция для предсказания с помощью LSTM
def lstm_forecast(data, steps=10):
    scaler = MinMaxScaler(feature_range=(0, 1))
    data_scaled = scaler.fit_transform(data.reshape(-1, 1))

    # Подготовка данных для LSTM
    def create_dataset(data, time_step=1):
        X, Y = [], []
        for i in range(len(data) - time_step):
            X.append(data[i:(i+time_step), 0])
            Y.append(data[i + time_step, 0])
        return np.array(X), np.array(Y)

    time_step = 3
    X, Y = create_dataset(data_scaled, time_step)
    X = X.reshape(X.shape[0], X.shape[1], 1)

    # Создаем модель LSTM
    model = Sequential()
    model.add(LSTM(units=50, return_sequences=False, input_shape=(X.shape[1], 1)))
    model.add(Dense(units=1))
    model.compile(optimizer='adam', loss='mean_squared_error')
    model.fit(X, Y, epochs=100, batch_size=32, verbose=0)

    # Прогнозирование
    forecast = []
    input_data = data_scaled[-time_step:].reshape(1, time_step, 1)
    for _ in range(steps):
        pred = model.predict(input_data, verbose=0)
        forecast.append(pred[0][0])
        input_data = np.append(input_data[:, 1:, :], pred.reshape(1, 1, 1), axis=1)

    forecast = scaler.inverse_transform(np.array(forecast).reshape(-1, 1))
    return forecast.flatten()

# Прогнозируем на 2021-2030 для каждого типа топлива
forecast_results = {}

for fuel in df_actual['Топливо'].unique():
    data_fuel = df_actual[df_actual['Топливо'] == fuel]

    # Преобразуем в массив numpy
    actual_data = np.array(data_fuel['Валовое потребление ТЭР'].values, dtype=np.float32).reshape(-1, 1)

    # Прогнозируем
    arima_pred = arima_forecast(actual_data.flatten())  # ARIMA работает с 1D
    linreg_pred = linear_regression_forecast(actual_data.flatten())
    rf_pred = rf_forecast(actual_data.flatten())
    lstm_pred = lstm_forecast(actual_data)

    forecast_results[fuel] = {
        'ARIMA': arima_pred,
        'Linear Regression': linreg_pred,
        'Random Forest': rf_pred,
        'LSTM': lstm_pred
    }

    # --- Расчёт и сохранение метрик ---
    # Сравниваем последние 10 фактических значений с прогнозом (если длина прогноза 10)
    actual = actual_data.flatten()[-10:]
    preds = {
        'ARIMA': arima_pred,
        'Linear Regression': linreg_pred,
        'Random Forest': rf_pred,
        'LSTM': lstm_pred
    }
    for model_name, pred in preds.items():
        if len(actual) == len(pred):
            mae, rmse = calculate_metrics(actual, pred)
            save_metrics_to_db(fuel, model_name, mae, rmse)
        else:
            print(f"[WARN] Длины actual и pred не совпадают для {fuel} - {model_name}")
    # --- конец блока метрик ---

    # Печать результатов
    print(f"\nПрогноз для {fuel} на 2021-2030:")
    for model_name in forecast_results[fuel]:
        print(f"{model_name}: {forecast_results[fuel][model_name]}")

    # Графики
    # plt.figure(figsize=(12, 6))
    # plt.plot(data_fuel['Год'], data_fuel['Валовое потребление ТЭР'], label=f'{fuel} (фактическое)', color='blue')
    # years_forecast = range(2021, 2031)
    # plt.plot(years_forecast, forecast_results[fuel]['ARIMA'], label=f'{fuel} (ARIMA)', color='red', linestyle='--')
    # plt.plot(years_forecast, forecast_results[fuel]['Linear Regression'], label=f'{fuel} (Linear Regression)', color='green', linestyle='--')
    # plt.plot(years_forecast, forecast_results[fuel]['Random Forest'], label=f'{fuel} (Random Forest)', color='purple', linestyle='--')
    # plt.plot(years_forecast, forecast_results[fuel]['LSTM'], label=f'{fuel} (LSTM)', color='orange', linestyle='--')
    # all_years = list(data_fuel['Год']) + list(years_forecast)
    # all_data_arima = list(data_fuel['Валовое потребление ТЭР']) + list(forecast_results[fuel]['ARIMA'])
    # all_data_linreg = list(data_fuel['Валовое потребление ТЭР']) + list(forecast_results[fuel]['Linear Regression'])
    # all_data_rf = list(data_fuel['Валовое потребление ТЭР']) + list(forecast_results[fuel]['Random Forest'])
    # all_data_lstm = list(data_fuel['Валовое потребление ТЭР']) + list(forecast_results[fuel]['LSTM'])
    # plt.plot(all_years, all_data_arima, color='red', linestyle='--', alpha=0.5)
    # plt.plot(all_years, all_data_linreg, color='green', linestyle='--', alpha=0.5)
    # plt.plot(all_years, all_data_rf, color='purple', linestyle='--', alpha=0.5)
    # plt.plot(all_years, all_data_lstm, color='orange', linestyle='--', alpha=0.5)
    # plt.title(f'Прогноз потребления {fuel} на 2021-2030')
    # plt.xlabel('Год')
    # plt.ylabel('Потребление ТЭР')
    # plt.legend(loc='best')
    # plt.grid(True)
    # plt.show()

import matplotlib.pyplot as plt
import numpy as np
import pandas as pd
from mpl_toolkits.mplot3d import Axes3D

# Годы прогнозирования
years_past = np.arange(2005, 2021)
years_future = np.arange(2021, 2031)
years = np.concatenate((years_past, years_future))

# Получаем список видов топлива
fuels = df_actual['Топливо'].unique()

# Цветовая карта моделей
models = ['ARIMA', 'Linear Regression', 'Random Forest', 'LSTM']
colormaps = ['viridis', 'plasma', 'cividis', 'magma']

# Увеличенный размер фигуры
fig = plt.figure(figsize=(24, 16))

for i, model_name in enumerate(models):
    ax = fig.add_subplot(2, 2, i + 1, projection='3d')

    # Создаем матрицу данных
    Z = np.zeros((len(fuels), len(years)))

    for j, fuel in enumerate(fuels):
        # Фактические данные
        actual_data = df_actual[df_actual['Топливо'] == fuel]['Валовое потребление ТЭР'].values
        Z[j, :len(actual_data)] = actual_data

        # Прогнозные данные для данной модели
        forecast_data = forecast_results[fuel][model_name]
        Z[j, len(actual_data):] = forecast_data

    # Создаем сетку координат
    X, Y = np.meshgrid(years, np.arange(len(fuels)))

    # Отображаем поверхность
    ax.plot_surface(X, Y, Z, cmap=colormaps[i], edgecolor='k', alpha=0.85)

    # Настройка осей с увеличенным шрифтом
    ax.set_xlabel('Год', fontsize=14, labelpad=12)
    ax.set_ylabel('Топливо', fontsize=14, labelpad=12)
    ax.set_zlabel('Потребление ТЭР (млн. тонн)', fontsize=14, labelpad=12)
    ax.set_title(f'Модель: {model_name}', fontsize=16, pad=16)

    # Улучшенные подписи оси Y (названия топлива)
    ax.set_yticks(np.arange(len(fuels)))
    ax.set_yticklabels(fuels, fontsize=12, rotation=30, ha='right')  # Подписи под углом

    # Настройка угла обзора
    ax.view_init(elev=30, azim=50)  # Немного другой угол для лучшей видимости

# Улучшенный отступ между графиками
plt.tight_layout(pad=5)
# plt.show()

# Выводим все метрики
print_all_metrics()